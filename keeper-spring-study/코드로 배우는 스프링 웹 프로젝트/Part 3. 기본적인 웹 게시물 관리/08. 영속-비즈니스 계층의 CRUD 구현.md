# Chapter 08 영속/비즈니스 계층의 CRUD 구현
- 코드를 이용해서 데이터에 대한 `CRUD(Create, Read, Update, Delete)` 작업 진행
- 영속 계층의 작업은 항상 다음과 같은 순서로 진행
    1. 테이블의 칼럼 구조를 반영하는 VO(Value Object) 클래스의 생성
    2. MyBatis의 Mapper 인터페이스의 작성/XML 처리
    3. 작성한 Mapper 인터페이스의 테스트

## 8.1 영속 계층의 구현 준비

### A. VO 클래스의 작성
- `@Data` 어노테이션 사용

### B. Mapper 인터페이스와 Mapper XML
- SQL이 복잡해지면
    - `어노테이션`의 경우 코드를 수정하고 다시 빌드 하는 등의 유지 보수성이 떨어지는 이유로 기피
    - `XML`의 경우 단순 텍스트를 수정하는 과정만으로 처리가 끝

#### Mapper 인터페이스
- VO 클래스를 이용하여 필요한 SQL 어노테이션의 속성값으로 처리
- SQL 작성할 때는 반드시 `;`이 없도록 작성
- `@Select` 어노테이션을 사용하는 방법, `XML`을 이용한 방법이 존재
- XML
    - <mapper>의 `namespace` : Mapper 인터페이스와 동일한 이름
    - <select>의 `id` : 메서드 이름과 동일하게 작성
    - <select>의 `resultType` : 쿼리의 결과를 특정 클래스 객체로 만들기 위해 사용
    - `CDATA` : XML에서 부등호를 사용하기 위해 사용
<br>

## 8.2 영속 영역의 CRUD 구현
- 웹 프로젝트 구조에서 마지막 영역이 영속 영역이지만, 구현을 가장 먼저 할 수 있는 영역도 영속 영역
- 비즈니스 로직과 무관하게 CRUD 작업을 작성할 수 있음
- MyBatis는 내부적으로 JDBC의 `PreparedStatement`를 활용
    - 필요한 파라미터를 처리하는 `?`에 대한 치환은 `#{속성}`을 이용해서 처리

### A. create(insert) 처리
- 시퀀스를 이용해 자동으로 데이터가 추가될 때 번호가 만들어지는 방식
- 자동으로 PK 값이 정해지는 경우 2가지 방식으로 처리 가능
    1. insert만 처리되고 생성된 PK 값을 알 필요가 없는 경우
    2. insert문이 실행되고 생성된 PK 값을 알아야 하는 경우
- `@SelectKey` : PK값을 미리(before) 처리해 두고 특정한 이름으로 결과를 보관하는 방법

### B. read(select) 처리
- `BoardVO` 클래스의 `bno` 타입 정보를 이용해서 처리
- MyBatis는 bno라는 칼럼이 존재하면 인스턴스의 `setBno()`를 호출
- MyBatis의 모든 파라미터와 리턴 타입의 처리는 `get 파라미터명()`, `set 칼럼명()`의 규칙으로 호출
    - #{속성}이 1개만 존재하는 경우에는 별도의 `get 파라미터명()`을 사용하지 않고 처리

### C. delete 처리
- 특정한 데이터를 삭제하는 작업 역시 PK 값을 이용해서 처리
- 등록, 삭제, 수정과 같은 DML(Data Manipulation Language)작업은 `몇 건의 데이터가 삭제(혹은 수정)되었는지` 반환할 수 있음

### D. update 처리
- 게시물의 업데이트는 제목, 내용, 작성자를 수정한다고 가정
- 업데이트할 때는 최종 수정시간을 데이터베이스 내 현재 시간으로 수정
- `몇 개의 데이터가 수정되었는가?`를 처리할 수 있는 int 타입 메서드